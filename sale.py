# -*- encoding: utf-8 -*-
##############################################################################
#
#    OfficeBeacon Administrative Pvt. Ltd
#    RTL Code
#    Copyright (C) 2012 (http://www.officebeacon.com)
#
##############################################################################

from openerp import models, fields, api, _
from openerp.exceptions import Warning
from lxml import etree
import ast
import base64
import requests


from datetime import datetime, timedelta, date, timedelta
from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT
#from pandas.tseries.holiday import Holiday

class sale_order_line(models.Model):
    _inherit = 'sale.order.line'

    additional_product_components = fields.Text('Additional Product Components', copy=False)

    @api.multi
    def product_id_change(self, pricelist, product, qty=0, uom=False, qty_uos=0, uos=False, name='', partner_id=False,lang=False, update_tax=True, date_order=False, packaging=False, fiscal_position=False, flag=False):
        temp_res = super(sale_order_line, self).product_id_change(pricelist, product, qty=qty,
            uom=uom, qty_uos=qty_uos, uos=uos, name=name, partner_id=partner_id,
            lang=lang, update_tax=update_tax, date_order=date_order, packaging=packaging, fiscal_position=fiscal_position, flag=flag)
        if temp_res.get('value', False):
            values = temp_res.get('value')
            if values.get('product_uos_qty', False) and values.get('price_unit', False) <= 0.0 and values.get('ltm_charge') <= 0.0:
                price_list_obj = self.env['product.pricelist']
                product_obj = self.env['product.product']
                product_id = product_obj.browse([product])
                product_tmpl_id = product_id.product_tmpl_id
                items_ids = []
                for pricelist in price_list_obj.browse([pricelist]):
                    for version_id in pricelist.version_id:
                        for item in version_id.items_id:
                            if item.product_tmpl_id.id == product_tmpl_id.id:
                                items_ids.append({'id':item.id, 'min_quantity': item.min_quantity})
                if items_ids:
                    newlist = sorted(items_ids, key=lambda k: k['min_quantity'])[0]
                    min_quantity = float(newlist.get('min_quantity'))
                    if values.get('product_uos_qty') < min_quantity:
                        for item in temp_res:
                            if item == 'value':
                                temp_res[item]['ltm_charge'] = product_tmpl_id.ltm_charge or 0.0
        return  temp_res


class sale_order(models.Model):
    _inherit = 'sale.order'
    
    @api.one
    def _check_mo(self):
        mo_obj = self.env['mrp.production']
        mo_ids = mo_obj.search([('origin','ilike',self.name),('state','not in', ['cancel'])])
        if mo_ids:
            self.is_mo_created = True
        else:
            self.is_mo_created = False
    
    ticket_generated = fields.Boolean('Ticket Generated', invisible=True, copy=False)
    ticket_button_visible = fields.Boolean('Ticket Generated Button Visible', invisible=True, copy=False)
    generated_by_admin = fields.Boolean('Is Generated By Admin?', copy=False)
    generated_by_oem = fields.Boolean('Is Generated By OEM?', copy=False)
    zorch_sale_order = fields.Char("Zorch Sales order", copy=False)
    zorch_po_number = fields.Char("Zorch PO Number", copy=False)
    zorch_visible = fields.Boolean('Zorch Fields Visible')
    is_mo_created = fields.Boolean(string='Is MO Created?')
    
    temp_bool = fields.Boolean('Temp')
#     is_mo_created = fields.Boolean(string='Is MO Created?',compute='_check_mo')

    def onchange_partner_id(self, cr, uid, id, partner_id, context=None):
        result = super(sale_order, self).onchange_partner_id(cr, uid, id, partner_id, context=context)
        result['value'].update({'zorch_sale_order': '', 'zorch_po_number': ''})
        if partner_id:
            partner = self.pool.get('res.partner').browse(cr, uid, partner_id, context=context)
            zorch_id = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'ob_dard_changes', 'zorch_categ_id')[1]
            if partner.category_id and zorch_id in partner.category_id.ids:
                result['value'].update({'zorch_visible':True})
            else:
                result['value'].update({'zorch_visible':False})
        else:
            result['value'].update({'zorch_visible':False})
        return result
    
    def _make_invoice(self, cr, uid, order, lines, context=None):
        inv_id = super(sale_order,self)._make_invoice(cr,uid,order,lines,context)
        if inv_id:
            if order.zorch_visible:
                self.pool.get('account.invoice').write(cr,uid,inv_id,{
                    'zorch_visible': order.zorch_visible,
                    'zorch_sale_order': order.zorch_sale_order,
                    'zorch_po_number': order.zorch_po_number,
                    'client_po_ref': order.client_po_ref
                    })
        return inv_id  

    @api.multi
    def release_sales_order(self):
        order_ids = self._context.get('active_ids')
        orders = self.browse(order_ids)
        #self._context.update({'by_pass': True})
        orders.with_context({'by_pass': True}).write({'has_limit': False, 'by_pass': True})
        
        self._cr.execute("update sale_order set credit_hold=NULL where id=%s", (order_ids[0],))
        self._cr.commit()
        
#         account_manager_group_id = self.env['ir.model.data'].get_object_reference('account', 'group_account_manager')[1]
#         current_user_groups_ids = [group.id for group in self.env['res.users'].browse(self._uid).groups_id]
#         if not account_manager_group_id in current_user_groups_ids:
#             raise Warning('You do not have the access to release the order.\n'
#                           ' Please contact your Financial Manager.')
        return


    @api.multi
    def action_button_confirm(self):
        res = super(sale_order, self).action_button_confirm()
        
        
        #Start Logic to check MO is generated for particular SO or not
        
        mo_obj = self.env['mrp.production']
        mo_ids = mo_obj.search([('origin','ilike',self.name),('state','not in', ['cancel'])])
        if mo_ids:
            self.is_mo_created = True
        else:
            self.is_mo_created = False
        
        
        #End Logic to check MO is generated for particular SO or not
        
        
        import time
        #updated_date = datetime.strptime(self.ship_dt, DEFAULT_SERVER_DATE_FORMAT).date()
        updated_date = datetime.strptime(time.strftime("%Y-%m-%d"), DEFAULT_SERVER_DATE_FORMAT).date()
        list_of_holidays = []
        #Start logic to get all Holidays
        import calendar
        cal = calendar.Calendar(0)
        #Thanksgiving: Fourth Thursday of November
        month = cal.monthdatescalendar(updated_date.year, 11)
        fourth_week = month[3]
        date_of_fourth_thursday = fourth_week[3]
        list_of_holidays.append(date_of_fourth_thursday)
        
        #Memorial Day: Last Monday of month May every year.
        month = cal.monthdatescalendar(updated_date.year, 5)
        last_week = month[-1]
        date_of_last_monday = last_week[0]
        list_of_holidays.append(date_of_last_monday)
        
        #Labor Day: First Monday of month September every year
        month = cal.monthdatescalendar(updated_date.year, 9)
        first_week = month[0]
        date_of_first_monday = first_week[0]
        
        if date_of_first_monday.month == 8:
            first_week = month[1]
            date_of_first_monday = first_week[0]
        list_of_holidays.append(date_of_first_monday)
        
        
        christmas_day = str(updated_date.year) + '-' +'12' + '-' + '25'
        list_of_holidays.append(datetime.strptime(christmas_day, "%Y-%m-%d").date())
        
        christmas_eve = str(updated_date.year) + '-' +'12' + '-' + '24'
        list_of_holidays.append(datetime.strptime(christmas_eve, "%Y-%m-%d").date())
        
        new_year_previous = str(updated_date.year - 1) + '-' +'1' + '-' + '1'
        new_year = str(updated_date.year) + '-' +'1' + '-' + '1'
        new_year_next = str(updated_date.year + 1) + '-' +'1' + '-' + '1'
        list_of_holidays.append(datetime.strptime(new_year_previous, "%Y-%m-%d").date())
        list_of_holidays.append(datetime.strptime(new_year, "%Y-%m-%d").date())
        list_of_holidays.append(datetime.strptime(new_year_next, "%Y-%m-%d").date())
        
        independence_day =  str(updated_date.year) + '-' +'7' + '-' + '4'
        list_of_holidays.append(datetime.strptime(independence_day, "%Y-%m-%d").date())
        
        good_friday = global_path = self.env['ir.config_parameter'].get_param('good.friday')
        if good_friday:
            list_of_holidays.append(datetime.strptime(good_friday, "%Y-%m-%d").date())
        
        #End logic to get all Holidays
        #print '_______list_of_holidays______',list_of_holidays
        
        check_date = updated_date
        
        final_count = 1
        for i in range(8):
            #print '_____check_date____',check_date
            if check_date not in list_of_holidays and check_date.strftime("%A") not in ['Saturday','Sunday']:
                #print '-------working_day----------',check_date
                final_count += 1
            #else:
                #print '------non-working_day----------',check_date
            if final_count == 5:
                final_date = check_date
                #break
            check_date = check_date + timedelta(days=1)
        last_date = final_date + timedelta(days=1)

        if last_date.strftime("%A") == 'Saturday':
            last_date = last_date + timedelta(days=2)
        if last_date.strftime("%A") == 'Sunday':
            last_date = last_date + timedelta(days=1)
        
        
        #print 'last_date_____',last_date
        self.ship_dt = last_date
        
        for order in self:
            for line in order.order_line:
                for procurement in line.procurement_ids:
                    if procurement.production_id:
                        order.ticket_button_visible = True
        return res
    
    
    
    @api.multi
    def generate_ticket(self):
        user_browse = self.env['res.users'].browse(self._uid)
        for group in user_browse.groups_id:
            if group.name == 'Internal Team':
                
                if self.temp_bool == False:
                    if self.generated_by_admin == True or self.generated_by_oem == True:
                        raise Warning(_('The Ticket Document is already generated by Admin Or Order Entry Manager.'))
                    if self.ticket_generated:
                        raise Warning(_('The ticket report is already downloaded. Please contact Administrator to re-download of this document.'))
                
            if group.name == 'DARD Admin':
                self.generated_by_admin = True
            
            if group.name == 'Order Entry Manager':
                self.generated_by_oem = True
                
        #self.ticket_generated = True
            
            
        return {
            'type': 'ir.actions.report.xml',
            'report_name': 'ob_dard_changes.report_generateticket',
            'report_type': u'qweb-pdf',
            }
    
    @api.multi
    def generate_ticket_oem(self):
        
        #this code will check if logged in user is DARD admin or not
        user_browse = self.env['res.users'].browse(self._uid)
        for group in user_browse.groups_id:
            if group.name == 'DARD Admin':
                self.generated_by_admin = True
            if group.name == 'Order Entry Manager':
                self.generated_by_oem = True
        
        self.ticket_generated = True
        
        return {
            'type': 'ir.actions.report.xml',
            'report_name': 'ob_dard_changes.report_generateticket',
            'report_type': u'qweb-pdf',
            }
    
    
    @api.v7
    def fields_view_get(self, cr, uid, view_id=None, view_type='form', context=None, toolbar=False, submenu=False):
        context = context or {}
        result = super(sale_order, self).fields_view_get(cr, uid, view_id=view_id, view_type=view_type, context=context,
                                toolbar=toolbar, submenu=False)
        #This logic is to hide Generate Ticket button for "Order Entry Manager" group users
        user_browse = self.pool.get('res.users').browse(cr, uid, uid)
        if user_browse.groups_id:
            for group in user_browse.groups_id:
                if group.name == 'Order Entry Manager':
                    form_string = result['arch']
                    form_node = etree.XML(form_string)
                    button_node = form_node.xpath("//button[@name='generate_ticket']")
                    for button in button_node:
                        button.getparent().remove(button)
                    result['arch'] = etree.tostring(form_node)
        return result
    
    def action_quotation_send(self, cr, uid, ids, context=None):
        '''  Override to use a modified template that includes custom msg for state prepared'''
        action_dict = super(sale_order, self).action_quotation_send(cr, uid, ids, context=context)
        try:
            template_id = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'ob_dard_changes', 'email_template_edi_sale')
            # assume context is still a dict, as prepared by super
            ctx = action_dict['context']
            ctx['default_template_id'] = template_id[1]
            ctx['default_use_template'] = True
        except Exception:
            pass
        return action_dict
    
    
    
class SaleOrderLineImages(models.Model):
    _inherit = "sale.order.line.images"

    virtual_file_path = fields.Text("Virtual File")
    """
    By overriding these methods we will able to add virtual_file_name(File Name) and path(download_link) on SOLine
    >create() & write()
    """
    @api.model
    def create(self, vals):
        if vals.get('virtual_file_path',False):
            vals = self.store_file_physically(vals)
        return super(SaleOrderLineImages, self).create(vals)
 
    @api.one
    def write(self, vals):
        if vals.get('virtual_file_path',False):
            vals = self.store_file_physically(vals)
        return super(SaleOrderLineImages, self).write(vals)
 
 
    @api.model
    def store_file_physically(self, vals, isArtImage=False):
        if vals and 'is_url' in vals.keys() and vals.get('is_url') == True:
            return super(SaleOrderLineImages, self).store_file_physically(vals, isArtImage)
        
        if 'virtual_file_path' not in vals.keys():
            return {}
        # not calling super here because it won't work with overwritten new field virtual_file_path (Text instead of binary)
        # vals = super(SaleOrderLineImages, self).store_file_physically(vals, isArtImage)
        web_path = self.env['ir.config_parameter'].get_param('global.web.path')
        if vals.get('virtual_file_path') == '[]':
            vals.update({'virtual_file_name_url': '', 'virtual_file_name': ''})
            return vals
        else:
            virtual_file_path = ast.literal_eval(vals.get('virtual_file_path'))
            if virtual_file_path:
                virtual_file_data = virtual_file_path.pop()
                if virtual_file_data:
                    vals.update({'virtual_file_name_url': virtual_file_data.get('name'), 'virtual_file_name': virtual_file_data.get('orignal_name')})
        return vals


class procurement_order(models.Model):
    _inherit = 'procurement.order'

    @api.model
    def create(self, vals):
        if vals.get('sale_line_id', False):
            line_id = self.env['sale.order.line'].browse(vals.get('sale_line_id', False))
            if line_id.over_run and vals.get('sub_origin', False) and vals.get('product_qty', False) and vals.get('sub_origin') == line_id.sol_seq:
                vals.update({'product_qty': line_id.overrun_qty, 'product_uos_qty': line_id.overrun_qty})
        return super(procurement_order, self).create(vals)



from openerp import api
from openerp import SUPERUSER_ID
from openerp.exceptions import AccessError,ValidationError
from openerp.osv import osv
from openerp.tools import config
from openerp.tools.misc import find_in_path
from openerp.tools.translate import _
from openerp.addons.web.http import request
from openerp.tools.safe_eval import safe_eval as eval

import re
import time
import base64
import logging
import tempfile
import lxml.html
import os
import subprocess
from contextlib import closing
from distutils.version import LooseVersion
from functools import partial
from pyPdf import PdfFileWriter, PdfFileReader
class Report(osv.Model):
    _inherit = "report"
    
    
    @api.v7
    def get_pdf(self, cr, uid, ids, report_name, html=None, data=None, context=None):
        
        if report_name == 'ob_dard_changes.report_generateticket':
            user_browse = self.pool.get('res.users').browse(cr, uid, uid)
            for group in user_browse.groups_id:
                if group.name == 'Internal Team':
                    name_generated = ''
                    name_oem_or_admin = ''
                    if ids:
                        for sale_id in ids:
                            sale_obj = self.pool.get('sale.order').browse(cr, uid, sale_id)
                            if sale_obj.ticket_generated:
                                name_generated += sale_obj.name + ","
                            
                            if sale_obj.generated_by_admin == True or sale_obj.generated_by_oem == True:
                                name_oem_or_admin += sale_obj.name + ","
                            
                            self.pool.get('sale.order').write(cr, uid, sale_id, {'ticket_generated': True, 'temp_bool': True})
                            
                    # if name_oem_or_admin != '':
                    #     raise ValidationError(_('The Ticket Document is already generated by Admin Or Order Entry Manager : %s' % (name_oem_or_admin)))
                    # if name_generated != '':
                    #     raise ValidationError(_('Ticket Generated For Following Order(s) : %s' % (name_generated)))
                
        
        
        """This method generates and returns pdf version of a report.
        """
        if context is None:
            context = {}

        if html is None:
            html = self.get_html(cr, uid, ids, report_name, data=data, context=context)

        html = html.decode('utf-8')  # Ensure the current document is utf-8 encoded.

        # Get the ir.actions.report.xml record we are working on.
        report = self._get_report_from_name(cr, uid, report_name)
        # Check if we have to save the report or if we have to get one from the db.
        save_in_attachment = self._check_attachment_use(cr, uid, ids, report)
        # Get the paperformat associated to the report, otherwise fallback on the company one.
        if not report.paperformat_id:
            user = self.pool['res.users'].browse(cr, uid, uid)
            paperformat = user.company_id.paperformat_id
        else:
            paperformat = report.paperformat_id

        # Preparing the minimal html pages
        css = ''  # Will contain local css
        headerhtml = []
        contenthtml = []
        footerhtml = []
        irconfig_obj = self.pool['ir.config_parameter']
        base_url = irconfig_obj.get_param(cr, SUPERUSER_ID, 'report.url') or irconfig_obj.get_param(cr, SUPERUSER_ID, 'web.base.url')

        # Minimal page renderer
        view_obj = self.pool['ir.ui.view']
        render_minimal = partial(view_obj.render, cr, uid, 'report.minimal_layout', context=context)

        # The received html report must be simplified. We convert it in a xml tree
        # in order to extract headers, bodies and footers.
        try:
            root = lxml.html.fromstring(html)
            match_klass = "//div[contains(concat(' ', normalize-space(@class), ' '), ' {} ')]"

            for node in root.xpath("//html/head/style"):
                css += node.text

            for node in root.xpath(match_klass.format('header')):
                body = lxml.html.tostring(node)
                header = render_minimal(dict(css=css, subst=True, body=body, base_url=base_url))
                headerhtml.append(header)

            for node in root.xpath(match_klass.format('footer')):
                body = lxml.html.tostring(node)
                footer = render_minimal(dict(css=css, subst=True, body=body, base_url=base_url))
                footerhtml.append(footer)

            for node in root.xpath(match_klass.format('page')):
                # Previously, we marked some reports to be saved in attachment via their ids, so we
                # must set a relation between report ids and report's content. We use the QWeb
                # branding in order to do so: searching after a node having a data-oe-model
                # attribute with the value of the current report model and read its oe-id attribute
                if ids and len(ids) == 1:
                    reportid = ids[0]
                else:
                    oemodelnode = node.find(".//*[@data-oe-model='%s']" % report.model)
                    if oemodelnode is not None:
                        reportid = oemodelnode.get('data-oe-id')
                        if reportid:
                            reportid = int(reportid)
                    else:
                        reportid = False

                # Extract the body
                body = lxml.html.tostring(node)
                reportcontent = render_minimal(dict(css=css, subst=False, body=body, base_url=base_url))

                contenthtml.append(tuple([reportid, reportcontent]))

        except lxml.etree.XMLSyntaxError:
            contenthtml = []
            contenthtml.append(html)
            save_in_attachment = {}  # Don't save this potentially malformed document

        # Get paperformat arguments set in the root html tag. They are prioritized over
        # paperformat-record arguments.
        specific_paperformat_args = {}
        for attribute in root.items():
            if attribute[0].startswith('data-report-'):
                specific_paperformat_args[attribute[0]] = attribute[1]

        # Run wkhtmltopdf process
        return self._run_wkhtmltopdf(
            cr, uid, headerhtml, footerhtml, contenthtml, context.get('landscape'),
            paperformat, specific_paperformat_args, save_in_attachment
        )

    
    
    
    
